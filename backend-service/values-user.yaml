replicaCount: 3

image:
  repository: REPLACE_WITH_ACR_LOGIN_SERVER/user
  pullPolicy: IfNotPresent

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
service:
  type: ClusterIP
  port: 80
  targetPort: 9001

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 85
  targetMemoryUtilizationPercentage: 80

serviceAccount:
  create: true
  name: user-sa
  # Automatically mount a ServiceAccount's API credentials, meaning the pod will run kubectl commands on the cluster which is a security risk
  automount: false
  clientId: ""

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  runAsNonRoot: true
  runAsUser: 65532
  runAsGroup: 65532
  fsGroup: 65532 # Change ownership of the volumes and file system to the non-root user
  seccompProfile:
    type: RuntimeDefault # Use the default seccomp profile for the container runtime
    # More information can be found here: https://kubernetes.io/docs/concepts/security/pod-security-policy/#seccomp

resources:
  requests:
    memory: "512Mi"
    cpu: "300m"
  limits:
    memory: "900Mi"
    cpu: "450m"

secretProvider:
  keyvaultName: azure-kv-secrets
  tenantID: ""
  secretName: app-connection-secrets # The name of the resulting Kubernetes Secret
  secrets:
    - remoteName: redis-conn-string
      envKey: REDIS_CONNECTION_STRING
    - remoteName: cosmos-conn-string
      envKey: COSMOS_CONNECTION_STRING

probes:
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 2
  failureThreshold: 3 

# Some Fixes
nameOverride: user
fullnameOverride: user